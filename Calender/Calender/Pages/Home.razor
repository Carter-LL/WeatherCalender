@page "/"
@using System.Text.Json
@using Calender.Models
@using System.Text.RegularExpressions;
@using System.Text
@inject HttpClient Http

<PageTitle>Monthly Holidays</PageTitle>

<h1>Holidays and Observances</h1>
<p>Select a month to plan!</p>

@if (monthsData != null)
{
    @if (monthsData.ContainsKey(selectedMonth))
    {
        <h2>@monthsData[selectedMonth].month_name</h2>
        <p>@monthsData[selectedMonth].summary</p>

        <h3>Timeline</h3>
        <ul>
            @for (int day = monthsData[selectedMonth].starting_day; day <= monthsData[selectedMonth].ending_day; day++)
            {
                string extra = "";
                @if (monthsData[selectedMonth].holidays.ContainsKey(day))
                {
                    extra = " - " + @monthsData[selectedMonth].holidays[day];
                }
                <li onclick="showModal()">
                    <time datetime="@day">@day</time>@extra
                </li>
            }
        </ul>
    }
}

@code {
    Dictionary<string, Month> monthsData;
    private string selectedMonth = getFullName(Convert.ToInt32(DateTime.Now.ToString("MM")));

    private Month[]? months;

    protected override async Task OnInitializedAsync()
    {
        Console.WriteLine(DateTime.Now.ToString("MM"));
        string name = getFullName(Convert.ToInt32(DateTime.Now.ToString("MM")));
        string jsonString = await Http.GetStringAsync("localdata/months.json");
        monthsData = JsonSerializer.Deserialize<Dictionary<string, Month>>(jsonString);

        GeoLocation geo = await GetGeoLocation(Http);
        Console.WriteLine(geo.Lat + " - " + geo.Lon);
    }

    // function to get the full month name
    static string getFullName(int month)
    {
        DateTime date = new DateTime(2020, month, 1);
        return date.ToString("MMMM");
    }

    // Helper function to generate the content for the file
    // Applying Open/Closed Principle (OCP) here
    // If we need to extend the file content generation logic in the future,
    // we can modify or extend this method without changing the WriteToFile method.
    private string GenerateHolidaysContent()
    {
        var monthData = monthsData[selectedMonth];
        StringBuilder content = new StringBuilder();

        content.AppendLine($"Holidays for {monthData.month_name} ({selectedMonth}):");
        content.AppendLine($"Summary: {monthData.summary}");
        content.AppendLine("Timeline:");

        for (int day = monthData.starting_day; day <= monthData.ending_day; day++)
        {
            string extra = monthData.holidays.ContainsKey(day) ? $" - {monthData.holidays[day]}" : string.Empty;
            content.AppendLine($"Day {day}{extra}");
        }

        return content.ToString();
    }

    // Function to get the GeoLocation (Latitude and Longitude)
    private static async Task<GeoLocation> GetGeoLocation(HttpClient client)
    {
        GeoLocation geo = new();
        string jsonString = await client.GetStringAsync("https://api.my-ip.io/v2/ip.json");

        // Regex to capture lat and lon values
        string pattern = @"""lat"":\s*(-?\d+\.\d+)\s*,\s*""lon"":\s*(-?\d+\.\d+)";
        Regex regex = new Regex(pattern);
        Match match = regex.Match(jsonString);

        if (match.Success)
        {
            string latString = match.Groups[1].Value;
            string lonString = match.Groups[2].Value;

            if (float.TryParse(latString, out float latFloat) && float.TryParse(lonString, out float lonFloat))
            {
                geo.Lat = (int)Math.Round(latFloat);  // Round to the nearest integer
                geo.Lon = (int)Math.Round(lonFloat);  // Round to the nearest integer
            }
        }

        return geo;
    }
}
